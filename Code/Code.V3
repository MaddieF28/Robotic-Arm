#include <Servo.h>

char buffer[10];   // buffer for incoming serial number
byte index = 0;

const int NUM_SERVOS = 6;
Servo servos[NUM_SERVOS];

uint8_t val = 0;           // current command
const int STEP_SIZE = 1;   // step per update for smooth movement

// Current servo positions
int currentPos[NUM_SERVOS] = {0, 0, 0, 0, 0, 0};

// Servo limits
int minAngle[NUM_SERVOS] = {-85, -55, -80, 0, 0, 0};
int maxAngle[NUM_SERVOS] = { 90, 150, 140, 90, 90, 180};

// Servo pins
int servoPins[NUM_SERVOS] = {3, 5, 6, 9, 10, 11};

// Microsecond ranges
int minUS[NUM_SERVOS] = {1250, 550, 500, 500, 500, 500};
int maxUS[NUM_SERVOS] = {2550, 1900, 1800, 1800, 1800, 2500};

// Zero offsets
int zeroOffset[NUM_SERVOS] = {7, 2, -50, 0, 50, 0};

// Servo update interval
const unsigned long SERVO_INTERVAL = 20;
unsigned long lastUpdate = 0;

void setup() {
  Serial.begin(9600);

  // attach all servos
  for (int i = 0; i < NUM_SERVOS; i++) {
    servos[i].attach(servoPins[i]);
    moveServo(i, currentPos[i]);
  }
}

void loop() {
  // Read incoming serial numbers
  while (Serial.available()) {
    char c = Serial.read();

    if (c == '\n') {          // end of number
      buffer[index] = '\0';   // terminate string
      val = (uint8_t)atoi(buffer);

      index = 0;              // reset buffer
    } else if (isDigit(c)) {
      if (index < sizeof(buffer) - 1) buffer[index++] = c;
    }
  }

  updateServos();
}

// ------------------------- Move servos -------------------------
void updateServos() {
  unsigned long now = millis();
  if (now - lastUpdate < SERVO_INTERVAL) return;
  lastUpdate = now;

  switch (val) {
    case 1: if(currentPos[0] - STEP_SIZE >= minAngle[0]) currentPos[0] -= STEP_SIZE; break;
    case 2: if(currentPos[0] + STEP_SIZE <= maxAngle[0]) currentPos[0] += STEP_SIZE; break;
    case 3: if(currentPos[1] + STEP_SIZE <= maxAngle[1]) currentPos[1] += STEP_SIZE; break;
    case 4: if(currentPos[1] - STEP_SIZE >= minAngle[1]) currentPos[1] -= STEP_SIZE; break;
    case 5: if(currentPos[2] + STEP_SIZE <= maxAngle[2]) currentPos[2] += STEP_SIZE; break;
    case 6: if(currentPos[2] - STEP_SIZE >= minAngle[2]) currentPos[2] -= STEP_SIZE; break;
    case 7: if(currentPos[3] - STEP_SIZE >= minAngle[3]) currentPos[3] -= STEP_SIZE; break;
    case 8: if(currentPos[3] + STEP_SIZE <= maxAngle[3]) currentPos[3] += STEP_SIZE; break;
    case 9: if(currentPos[4] - STEP_SIZE >= minAngle[4]) currentPos[4] -= STEP_SIZE; break;
    case 10: if(currentPos[4] + STEP_SIZE <= maxAngle[4]) currentPos[4] += STEP_SIZE; break;
    case 11: if(currentPos[5] + STEP_SIZE <= maxAngle[5]) currentPos[5] += STEP_SIZE; break;
    case 12: if(currentPos[5] - STEP_SIZE >= minAngle[5]) currentPos[5] -= STEP_SIZE; break;
    case 0:
    default: break; // stop moving immediately
  }

  // Apply positions
  for (int i = 0; i < NUM_SERVOS; i++) moveServo(i, currentPos[i]);
}

void moveServo(int index, int angle) {
  angle += zeroOffset[index];
  angle = constrain(angle, minAngle[index], maxAngle[index]);
  int pulse = map(angle, minAngle[index], maxAngle[index], minUS[index], maxUS[index]);
  servos[index].writeMicroseconds(pulse);
}
