#include <Servo.h>

char buffer[10];   // enough for 0–999999999
byte index = 0;

// ------------------------- Servos -------------------------
const int NUM_SERVOS = 6;
Servo servos[NUM_SERVOS];

uint8_t val = 0;
const int STEP_SIZE = 5;

// Current & target positions (logical angles)
int currentPos[NUM_SERVOS] = {90, 0, 0, 0, 0, 0};



// Per-servo angle limits
int minAngle[NUM_SERVOS] = {180, -90,  -90,  -130,  -120, -90};
int maxAngle[NUM_SERVOS] = { 0,   30,   90,  70,  90, 90};

// Servo pins
int servoPins[NUM_SERVOS] = {3,   5,    6,    9,    10, 11};

// Servo microsecond ranges (minUS, maxUS)
int minUS[NUM_SERVOS] = {1000, 500, 500, 550, 500, 1000};
int maxUS[NUM_SERVOS] = {2000, 1800, 1800, 1900, 1800, 2000};

int zeroOffset[NUM_SERVOS] = {0, -90, -90, 15, 90, 0};

// Smooth motion update interval (ms)
const unsigned long SERVO_INTERVAL = 200;
unsigned long lastUpdate = 0;


bool reversed[NUM_SERVOS] = {
  false, // 0 gripper
  true, // 1 neck
  false, // 2 rotation
  true,  // 3 elbow  
  false, // 4 bottom
  true  // 5 base
};


// ------------------------- Setup -------------------------
void setup() {
  Serial.begin(9600);

 
  // Attach servos
  for (int i = 0; i < NUM_SERVOS; i++) {
    servos[i].attach(servoPins[i]);

    if(i ==0){
      moveOne(i, currentPos[i]);
      continue;
    }
   
    moveServo(i, currentPos[i]); // initial position
    
  }

  // delay(1000);
  // moveServo(1, -90);
  // delay(2000);
  // moveServo(1, 0);
  // delay(2000);
  // moveServo(1, 10);
  // delay(2000);
  //  moveServo(1, 20);
  // delay(2000);
  //  moveServo(1, 30);
  // delay(2000);

  

}

unsigned long valstarttime = 0;
const unsigned long maxholdtime = 5000;

// ------------------------- Main loop -------------------------
void loop() {

   while (Serial.available()) {
    char c = Serial.read();

    if (c == '\n') {          // end of number
      buffer[index] = '\0';  // terminate string
     uint8_t newval = (uint8_t)atoi(buffer);
       if(newval != val)
       {
        val = newval;
        valstarttime = millis();
       }
   
      index = 0;              // reset buffer
    }
    else if (isDigit(c)) {
      if (index < sizeof(buffer) - 1) {
        buffer[index++] = c;
      }
    }

  }

       if(val != 0 && millis()-valstarttime > maxholdtime){
      val = 0;
    }
    
  updateServos(); 
}



// ------------------------- Smooth servo update -------------------------
void updateServos() {
  unsigned long now = millis();
  if (now - lastUpdate < SERVO_INTERVAL) return;
  lastUpdate = now;

  // Move the servo(s) one step based on current val.
  // val is treated as "hold-to-move" (level triggered).
 Serial.println(val);
  switch (val) {
    case 2: // bottom
      if (currentPos[4] + STEP_SIZE <= maxAngle[4]) currentPos[4] += STEP_SIZE;
      break;
    case 1: // servo 1 decrease
      if (currentPos[4] - STEP_SIZE >= minAngle[4]) currentPos[4] -= STEP_SIZE;
      break;
    case 3://elbow
      if (currentPos[3] + STEP_SIZE <= maxAngle[3]) currentPos[3] += STEP_SIZE;
      break;
    case 4:
      if (currentPos[3] - STEP_SIZE >= minAngle[3]) currentPos[3] -= STEP_SIZE;
      break;
    case 5://rotation
      if (currentPos[2] + STEP_SIZE <= maxAngle[2]) currentPos[2] += STEP_SIZE;
      break;
    case 6:
      if (currentPos[2] - STEP_SIZE >= minAngle[2]) currentPos[2] -= STEP_SIZE;
      break;
    case 7://neck
      if (currentPos[1] + STEP_SIZE <= maxAngle[1]) currentPos[1] += STEP_SIZE;
      break;
    case 8:
      if (currentPos[1] - STEP_SIZE >= minAngle[1]) currentPos[1] -= STEP_SIZE;
      break;
    case 9://gripper
      currentPos[0] = 0;
      break;
    case 10:
      currentPos[0] = 180;
      break;
    case 11://base
      if (currentPos[5] + STEP_SIZE <= maxAngle[5]) currentPos[5] += STEP_SIZE;
      break;
    case 12:
      if (currentPos[5] - STEP_SIZE >= minAngle[5]) currentPos[5] -= STEP_SIZE;
      break;
    case 0:
      currentPos[0]=90;
    default:
      // do nothing — stop moving immediately
      break;
  }

  // Apply the (possibly changed) currentPos to the servos
  for (int i = 0; i < NUM_SERVOS; i++) {
    if(i==0){
      moveOne(i, currentPos[i]);
      continue;
    }
    moveServo(i, currentPos[i]); // your existing moveServo handles zeroOffset, mapping, etc.
  }
}

// ------------------------- Move servo safely -------------------------
void moveServo(int index, int angle) {
   angle += zeroOffset[index];

  // Clamp angle to limits
  if (angle > maxAngle[index]) angle = maxAngle[index];
  if (angle < minAngle[index]) angle = minAngle[index];

  // Map to microseconds
  int pulse;
  
if (reversed[index]) {
  pulse = map(angle, minAngle[index], maxAngle[index],
              maxUS[index], minUS[index]);
} else {
  pulse = map(angle, minAngle[index], maxAngle[index],
              minUS[index], maxUS[index]);
}

  servos[index].writeMicroseconds(pulse);
}

void moveOne(int index, int angle){
  servos[index].write(angle);
}









